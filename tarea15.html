<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Tarea 15</title>
        <link href="Utilidad/estilo.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>
        <center>
        <a href="tarea14.html" class="button">- Anterior -</a>
        <a href="menu-tareas.html" class="button">- Menu Tareas -</a>
        <a href="tarea16.html" class="button">- Siguiente -</a>
        </center>
        <div>
            <br>
            <center><n class="titulo">Ruby</n></center><br>
            <n>Tarea #15</n><br>
            <br>
            <pre class="texto">
<n>Símbolos</n>

Un símbolo es el objeto más básico que puedes crear en Ruby: es un nombre y una ID interna. Los símbolos son útiles por que dado un símbolo, se refiere al mismo objeto en todo el programa. 
Por lo tanto, son más eficientes que los strings: dos strings con el mismo nombre, son dos objetos distintos. Esto implica un ahorra de tiempo y memoria.
puts "hola".object_id   # 21066960
puts "hola".object_id   # 21066730
puts :hola.object_id    # 132178
puts :hola.object_id    # 132178

Cada vez que se ha usado un string, se ha creado un objeto nuevo. Por tanto, ¿cuándo usar un string, y cuándo un símbolo?
•	Si el contenido del objeto es lo importante, usa un string.
•	Si la identidad del objeto es importante, usa un símbolo.
Ruby usa una tabla de símbolos interna con los nombres de las variables, objetos, métodos, clases… Por ejemplo, si hay un método con el nombre de control_movie, 
automáticamente se crea el símbolo :control_movie. Para ver la tabla de símbolos Symbol.all_symbols.

Hashes
Hashes, también conocidos como arrays asociativos, mapas o diccionarios, son parecidos a los arrays en que son una colección indexada de referencias a objetos. 
Sin embargo, mientras que en los arrays los índices son números, en los hashes se puede indexar con objetos de cualquier tipo: strings, expresiones regulares, etc.
Cuando se almacena un valor en un array, se dan dos objetos: el índice y el valor. A posteriori se puede obtener dicho valor, gracias al índice.
h = {'perro' => 'canino', 'gato' => 'felino', 'burro' => 'asno', 12 => 'docena'}
puts h.length   # 4
puts h['perro'] # 'canino'
puts h
puts h[12]

Comparados con los arrays, tenemos una ventaja significativa: se puede usar cualquier objeto como índice. Sin embargo, sus elementos no están ordenados, y es fácil usar un hash como una pila o cola.
Los hashes tienen un valor por defecto. Este valor se devuelve cuando se usan índices que no existen: el valor que se devuelve por defecto es nil.
Los símbolos como índices
Por las ventajas antes citadas, se usan los símbolos como índices:

persona = Hash.new
persona[:nombre] = 'Pedro'
persona[:apellido] = 'Picapiedra'
 
puts persona[:nombre]
que es equivalente a:
persona = {:nombre => 'Pedro', :apellido => 'Picapiedra'}
 
puts persona[:apellido]

<n>Sintaxis</n>

Comentarios y documentación embebida
Los comentarios en Ruby comienzan con el signo (#) , el interprete considera como comentario todo lo que viene después de este signo hasta el final de línea. Claro los comentarios no deben estar declarados entre otras sentencias de Ruby, por que no serían considerados como tal, sino como parte de la sentencia.
Operadores y su Precedencia
En ruby los operadores y su precedencia son:
Algunos operadores se utilizan para más de un propósito, por ejemplo, el operador << realiza desplazamiento de bits a la izquierda, pero también funciona para añadir en elementos como arrays, strings,etc.

Sentencias condicionales
En Ruby las sentencias condicionales se pueden expresar de 2 formas, La forma “if” y la forma “unless”. La diferencia entre estas es simple, mientras una sentencia con “if” se ejecuta si se cumple la evaluación, una sentencia con “unless” se  ejecutará si la evaluación no se cumple.
Ciclos
Ruby  aparte de los tradicionales “for”, “while” y “until”, existen otras maneras de iterar.

<n>Esqueleto de Ruby</n>
#!/usr/bin/env ruby
 
# Importamos las librerías que necesitemos
require librería x
require librería x

include Librería
 
class NombreClase < FXMainWindow

<n>Aplicación a descargar para trabajar con Ruby</n>

RubyMine
JetBrains RubyMine IDE proporciona un completo editor de código Ruby el cual es consciente de aspectos específicos de este lenguaje tan dinámico y, en consecuencia, ofrece asistencia para la codificación inteligente, la refactorización de código inteligente y otras capacidades para el análisis de código. Fácil configurar a la hora de crear un proyecto, cuenta también con gestión automática de gemas, soporte de Rake. 
Tipo de paradigma de Ruby
Ruby es un lenguaje de programación que pertenece al paradigma de tipo orientado a objetos.

<n>Programa hecho en Ruby</n>

#!/usr/bin/env ruby
 
# Importamos dependendecias de 'FXruby' 
require 'fox16'
require 'fox16/scintilla'
 
 
include Fox
 
class ScintillaTest  < FXMainWindow
 
  def initialize(app)
 
    # Llamamos al método que inicializa la clase base
    super(app, "Lector Simple de Archivos HTML", nil, nil, DECOR_ALL, 0, 0, 600, 800)
 
    # Creamos una barra de menú 
    menubar = FXMenuBar.new(self, LAYOUT_SIDE_TOP|LAYOUT_FILL_X)
 
    # Creamos una barra de estado 
    FXStatusBar.new(self,
      LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|STATUSBAR_WITH_DRAGCORNER)
 
    # El widget Scintilla de FXRuby ocupa el resto del espacio 
    sunkenFrame = FXHorizontalFrame.new(self,
      FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_FILL_Y)
    @scintilla = FXScintilla.new(sunkenFrame, nil, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y)
 
 
    # Opción del Menú para Abrir archivos HTML en una ventana de selección de archivos HTML  
    filemenu = FXMenuPane.new(self)
    FXMenuCommand.new(filemenu, "&Abrir\tCtl-O\tOpen...").connect(SEL_COMMAND) {
      openDialog = FXFileDialog.new(self, "Abrir Archivo")
      openDialog.selectMode = SELECTFILE_EXISTING
      openDialog.patternList = ["Archivos HTML (*.html)"]
      if openDialog.execute != 0
        loadFile(openDialog.filename)
      end
    }
 
    # Creamos el menú Archivo 
    FXMenuTitle.new(menubar, "&Archivo", nil, filemenu)
 
 
    # Opción del Menú para para Salir del Programa 
    FXMenuCommand.new(filemenu, "&Salir\tCtl-Q\tQuit application.", nil,
      getApp(), FXApp::ID_QUIT, 0)  
 
    # Opciones del Menu Ayuda
    helpmenu = FXMenuPane.new(self)    
    FXMenuCommand.new(helpmenu, "&Web...").connect(SEL_COMMAND) {
      
      # Abrimos el enlace en el navegador 
      url = "https://nubecolectiva.com/"
      
      if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
        system "start #{url}"
      elsif RbConfig::CONFIG['host_os'] =~ /darwin/
        system "open #{url}"
      elsif RbConfig::CONFIG['host_os'] =~ /linux|bsd/
        system "xdg-open #{url}"
      end
 
    }
 
    # Creamos el Menú Ayuda  
    FXMenuTitle.new(menubar, "&Ayuda", nil, helpmenu, LAYOUT_RIGHT)
    
  end
 
  # Abrimos el archivo HTML 
  def loadFile(filename)
    getApp().beginWaitCursor do
      text = File.open(filename, "r").read
      @scintilla.setText(text)
    end
  end
 
  # Creamos el espacio para el lector de archivos HTML 
  def create
    super
    show(PLACEMENT_SCREEN)
  end
end
 
if __FILE__ == $0
  # Construimos la aplicación 
  application = FXApp.new("ScintillaTest", "FoxTest")
 
  # Creamos la ventana para la aplicación 
  ScintillaTest.new(application)
 
  # Creamos la aplicación 
  application.create
 
  # Corremos la aplicación 
  application.run
end

            </pre>
        </div>
    </body>
</html>
